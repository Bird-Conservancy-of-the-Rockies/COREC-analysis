<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Suppl. S2: Model description and analysis methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="Analysis_methods_supplement_files/libs/clipboard/clipboard.min.js"></script>
<script src="Analysis_methods_supplement_files/libs/quarto-html/quarto.js"></script>
<script src="Analysis_methods_supplement_files/libs/quarto-html/popper.min.js"></script>
<script src="Analysis_methods_supplement_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Analysis_methods_supplement_files/libs/quarto-html/anchor.min.js"></script>
<link href="Analysis_methods_supplement_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Analysis_methods_supplement_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Analysis_methods_supplement_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Analysis_methods_supplement_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Analysis_methods_supplement_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Suppl. S2: Model description and analysis methods</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="analysis-model" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="analysis-model"><span class="header-section-number">1</span> Analysis model</h2>
<section id="indices" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="indices"><span class="header-section-number">1.1</span> Indices</h3>
<p><span class="math inline">\(i\)</span> - species; <span class="math inline">\(I=150\)</span> for all species</p>
<p><span class="math inline">\(j\)</span> - grid cells; <span class="math inline">\(J=285\)</span></p>
<p><span class="math inline">\(t\)</span> - years; <span class="math inline">\(T=3\)</span></p>
<p><span class="math inline">\(d\)</span> - distance bins; <span class="math inline">\(d_{[max]}=10\)</span></p>
<p><span class="math inline">\(d_{[mid]}\)</span>, <span class="math inline">\(d_{[low]}\)</span>, and <span class="math inline">\(d_{[high]}\)</span> are the distance mid-point, lower bound, and upper bound for distance bin <span class="math inline">\(d\)</span>. <span class="math inline">\(d_{[max,high]}\)</span> is the upper bound for the furthest distance bin (i.e., the radius of the entire point-level plot).</p>
<p><span class="math inline">\(r\)</span> – 2-min time removal bins within the 6-min survey; <span class="math inline">\(R=3\)</span></p>
</section>
<section id="data" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="data"><span class="header-section-number">1.2</span> Data</h3>
<p>A primary bird count observation consisted of the number of independent clusters detected for species <span class="math inline">\(i\)</span> at grid cell <span class="math inline">\(j\)</span> in year <span class="math inline">\(t\)</span>. The primary analysis model for birds therefore estimated species-specific abundance of clusters, which we multiplied by cluster size to derive predicted abundance of individuals (further details in <a href="#sec-N_p" class="quarto-xref">Section&nbsp;3.1</a>). We organized primary count data as a 3-dimensional data array <span class="math inline">\(\mathbf{n}\)</span>, where element <span class="math inline">\(n_{ijt}\)</span> is the number of clusters detected for species <span class="math inline">\(i\)</span> in grid cell <span class="math inline">\(j\)</span> and year <span class="math inline">\(t\)</span>. We accompanied this primary data array with two secondary arrays representing the distribution of counted individuals among time removal and distance bins, <span class="math inline">\(\mathbf{y_{[a]}}\)</span> and <span class="math inline">\(\mathbf{y_{[p]}}\)</span>, where elements <span class="math inline">\(y_{[a],ijtr}\)</span> and <span class="math inline">\(y_{[p],ijtd}\)</span> are counts within time removal bin <span class="math inline">\(r\)</span> and distance bin <span class="math inline">\(d\)</span>, respectively. For <span class="math inline">\(y_{[p],ijtd}\)</span>, we truncated the the furthest 5% of detections for each species for which we had <span class="math inline">\(\geq75\)</span> detections. Thus, for species with sufficient detections, the area of estimation corresponded with a circle of radius equal to the truncation distance centered on each surveyed point within a grid cell, and radius equal to the max distance for species with fewer detections.</p>
<p>To support path analysis, we accompanied the bird model with a series of path models relating human traffic with management covariates. For each path model, data were unscaled values for a human traffic covariate, <span class="math inline">\(X_{[H],j}\)</span>, transformed as necessary to meet distributional requirements for corresponding generalized linear models. Because management and human traffic covariates only varied spatially (see main text for rationale), data for path models were only indexed by grid cell. Moreover, <span class="math inline">\(X_{[H_{Conditional~traffic~intensity}],j}\)</span> was restricted to grid cells where <span class="math inline">\(X_{[H_{Humans~detected}],j}=1\)</span> (<span class="math inline">\(n=175\)</span>), and <span class="math inline">\(X_{[H_{Traffic~speed}],j}\)</span> was restricted to grid cells in which &gt;1 ping was recorded for at least one cell phone user in a single day (<span class="math inline">\(n=121\)</span>).</p>
</section>
<section id="ecological-process" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="ecological-process"><span class="header-section-number">1.3</span> Ecological process</h3>
<p>We modeled species abundance as</p>
<p><span id="eq-eco_N"><span class="math display">\[N_{ijt} \sim Poisson(\lambda_{ijt}), \tag{1}\]</span></span></p>
<p>where <span class="math inline">\(\lambda_{ijt}\)</span> is mean abundance and <span class="math inline">\(N_{ijt}\)</span> is latent (cluster) abundance. We modeled abundance variability as</p>
<p><span id="eq-eco_lambda"><span class="math display">\[log(\lambda_{ijt})=β_{0,i}+d_{[β_0],it}+\mathbf{β_{1,i}}×\mathbf{X_{jt}} \tag{2}\]</span></span></p>
<p>where <span class="math inline">\(\beta_{0,i}\)</span> is the intercept, <span class="math inline">\(d_{[β],it}\)</span> is a year-specific offset, and <span class="math inline">\(\mathbf{β_i}\)</span> is a vector of covariate relationships. We modeled <span class="math inline">\(\beta_{0,i}\)</span> and <span class="math inline">\(\mathbf{β_i}\)</span> as species-specific random effects, and <span class="math inline">\(d_{[β],it}\)</span> as a species×year-specific random effect. Hyper-parameter priors for these random effects were</p>
<span id="eq-eco_beta_mean"><span class="math display">\[\overline{\beta} \sim Normal(0,1), \tag{3}\]</span></span> <span id="eq-eco_beta_SD"><span class="math display">\[SD_{\beta} \sim gamma(1,1), \tag{4}\]</span></span> <span id="eq-eco_d_mean"><span class="math display">\[\overline{d_{[β_0]}} = 0, \tag{5}\]</span></span>
<center>
and
</center>
<p><span id="eq-eco_d_SD"><span class="math display">\[SD_{d_{[β_0]}} \sim gamma(1,1). \tag{6}\]</span></span></p>
</section>
<section id="observation-process" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="observation-process"><span class="header-section-number">1.4</span> Observation process</h3>
<p>We modeled count data as</p>
<p><span id="eq-obs_n"><span class="math display">\[n_{ijt} \sim Binomial\left(N_{ijt},p_{[p],ijt}×p_{[a],ijt}×\left(\frac{E_{jt}}{16}\right)\right), \tag{7}\]</span></span></p>
<p>where <span class="math inline">\(p_{[p],ijt}\)</span> and <span class="math inline">\(p_{[a],ijt}\)</span> are perceptibility and availability components of detection probability, and <span class="math inline">\(E_{jt}\)</span> is the number of point surveys completed in the grid cell (i.e., effort, so <span class="math inline">\(\frac{E_{jt}}{16}\)</span> is proportion effort). Each detection component can be expressed as the sum of probability vectors:</p>
<p><span id="eq-obs_p_a"><span class="math display">\[p_{[a],ijt}=\Sigma_{r=1}^{R} \pi_{[a],ijtr} \tag{8}\]</span></span></p>
<center>
and
</center>
<p><span id="eq-obs_p_p"><span class="math display">\[p_{[p],ijt}=∑_{d=1}^{d_{max}} π_{[p],ijtd}, \tag{9}\]</span></span></p>
<p>where <span class="math inline">\(π_{[a],ijtr}\)</span> and <span class="math inline">\(π_{[p],ijtd}\)</span> are detection probabilities within time removal and distance bins (hereafter bin probabilities), respectively. We modeled the distribution of counted clusters among time removal and distance bins, respectively, as</p>
<p><span id="eq-obs_y_a"><span class="math display">\[\mathbf{y_{[a],ijt}} \sim Multinomial \left(n_{ijt},\mathbf{π_{[a],ijt}^{[c]}} \right) \tag{10}\]</span></span></p>
<center>
and
</center>
<p><span id="eq-obs_y_p"><span class="math display">\[\mathbf{y_{[p],ijt}} \sim Multinomial \left(n_{ijt},\mathbf{π_{[p],ijt}^{[c]}} \right). \tag{11}\]</span></span></p>
<p>Bin probabilities for availability assume constant availability across the survey period,</p>
<p><span id="eq-obs_pi_a_bin"><span class="math display">\[π_{[a],ijtr}=p_{[ar],ijt} (1-p_{[ar],ijt})^{r-1}, \tag{12}\]</span></span></p>
<p>where <span class="math inline">\(p_{[ar],ijt}\)</span> is the availability for a single 2-min time removal bin. Bin probabilities for perceptibility account for increasing area of bins with increasing distance from the surveyor,</p>
<p><span id="eq-abundance_pi_p_bin"><span class="math display">\[π_{[p],ijtd}=\frac{p_{[pd],ijtd}A_d}{∑_{d=1}^{d_{[max]}}A_d}, \tag{13}\]</span></span></p>
<p>where <span class="math inline">\(p_{[pd],ijtd}\)</span> is the perceptibility within distance bin <span class="math inline">\(d\)</span> in year <span class="math inline">\(t\)</span>, and <span class="math inline">\(A_d\)</span> is the area of distance bin <span class="math inline">\(d\)</span>. Multinomial cell probabilites for modeling <span class="math inline">\(\mathbf{y_{[a],ijt}}\)</span> and <span class="math inline">\(\mathbf{y_{[p],ijt}}\)</span> represent bin probabilites scaled to sum to 1:</p>
<p><span id="eq-obs_pi_a_cell"><span class="math display">\[π_{[a],ijtr}^{[c]}=π_{[a],ijtr}⁄p_{[a],ijt}, \tag{14}\]</span></span></p>
<center>
and
</center>
<p><span id="eq-obs_pi_p_cell"><span class="math display">\[π_{[p],ijtd}^{[c]}=π_{[p],ijtd}⁄p_{[p],ijt}. \tag{15}\]</span></span></p>
<p>We modeled <span class="math inline">\(p_{[pd],ijtd}\)</span> using a hazard rate distance sampling model. Because of the lack of an analytical solution to the integral of the hazard rate function, we calculated <span class="math inline">\(p_{[pd],ijtd}\)</span> at the midpoint, <span class="math inline">\(d_{[mid]}\)</span>, of each distance class:</p>
<p><span id="eq-obs_p_pd"><span class="math display">\[p_{[pd],ijtd}=1-exp\left(-\left(\frac{d_{[mid]}}{h_{ijt}}\right)^{b_i}\right), \tag{16}\]</span></span></p>
<p>where <span class="math inline">\(h_{ijt}\)</span> and <span class="math inline">\(b_i\)</span> are estimated parameters for the hazard function. A critical assumption with distance sampling is that distance measurements are exact. With point-based surveys in particular, random measurement error can positively bias abundance estimates. Binning distances as we did here relaxes this assumption <span class="citation" data-cites="BucklandEtAl-2001">(<a href="#ref-BucklandEtAl-2001" role="doc-biblioref">Buckland et al. 2001</a>)</span>. Moreover, we train observers to collect accurate distance measurements from aural detections following the recommendation of Buckland et al.(2001, pg. 300), who state “It is the nearer detections for which accurate distance estimation is most critical, and for these, it is usually possible to determine which tree, bush or vegetation patch a singing or calling bird is in. Laser binoculars can then be used to measure the distance to an object (a tree, branch, bush, patch of ground, etc.) that is at about the same distance as the bird. Note that it is much better to measure accurately to a guessed location than to guess the distance to a guessed location. Not only does it remove a source of bias and variability but it also removes rounding error from distance estimates, making the task of modelling the data more straightforward.”</p>
<p>We used link functions to model spatial and temporal variability in availability and perceptibility:</p>
<p><span id="eq-obs_p_ar"><span class="math display">\[logit(p_{[ar],ijt}) = \theta_{0,i}+\mathbf{\theta_{1,i}}×\mathbf{X_{jt}} \tag{17}\]</span></span></p>
<center>
and
</center>
<p><span id="eq-obs_h"><span class="math display">\[log(h_{ijt}) = \zeta_{0,i}+\mathbf{\zeta_{1,i}}×\mathbf{X_{jt}}, \tag{18}\]</span></span></p>
<p>where <span class="math inline">\(\theta_{0,i}\)</span> and <span class="math inline">\(\zeta_{0,i}\)</span> are intercepts and <span class="math inline">\(\mathbf{\theta_i}\)</span> and <span class="math inline">\(\mathbf{\zeta_i}\)</span> are coefficient vectors for covariate relationships. As with ecological parameters, we modeled all intercepts and covariate coefficients as species-specific random effects. Hyper-parameter priors for detectability random effects were</p>
<span id="eq-obs_zeta0_mean"><span class="math display">\[\overline{\zeta_0} \sim Normal(4.5,0.67), \tag{19}\]</span></span> <span id="eq-obs_zeta_mean"><span class="math display">\[\overline{\zeta_1} \sim Normal(0,1), \tag{20}\]</span></span> <span id="eq-obs_beta_SD"><span class="math display">\[SD_{\zeta_0},SD_{\zeta_1} \sim gamma(1,1), \tag{21}\]</span></span> <span id="eq-obs_b_mean"><span class="math display">\[\overline{b} \sim Uniform(0,20), \tag{22}\]</span></span> <span id="eq-obs_b_SD"><span class="math display">\[SD_{b} \sim gamma(1,1), \tag{23}\]</span></span> <span id="eq-obs_theta0_mean"><span class="math display">\[\overline{\theta_0} \sim Normal(0,0.67), \tag{24}\]</span></span> <span id="eq-obs_theta_SD"><span class="math display">\[\overline{\theta_1} \sim Normal(0,1), \tag{25}\]</span></span>
<center>
and
</center>
<p><span id="eq-obs_b_SD"><span class="math display">\[SD_{\theta_0},SD_{\theta_1} \sim gamma(1,1). \tag{26}\]</span></span></p>
</section>
<section id="path-models" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="path-models"><span class="header-section-number">1.5</span> Path models</h3>
<p>We modeled each human traffic covariate as a function of management covariates using a generalized linear model:</p>
<p><span id="eq-path_distribution"><span class="math display">\[X_{[H],j} \sim F(p_{[H],j}) \tag{27}\]</span></span></p>
<center>
and
</center>
<p><span id="eq-path_link"><span class="math display">\[p_{[H],j} = f(B_{[H,0]}+\mathbf{B_{[H,1]}×X_{[M],j}}), \tag{28}\]</span></span></p>
<p>wherein <span class="math inline">\(F\)</span> is a probability function (probability distribution for continuous or probability mass for discrete <span class="math inline">\(X_{[H]}\)</span>, respectively), <span class="math inline">\(p_{[H]}\)</span> is a linear predictor, <span class="math inline">\(f\)</span> is a link function that scales the linear predictor, <span class="math inline">\(B_{[H,0]}\)</span> is a regression intercept, and <span class="math inline">\(\mathbf{B_{[H,1]}}\)</span> is a vector of regression slope parameters quantifying relationships with management covariates <span class="math inline">\(\mathbf{X_{[M]}}\)</span>. We modeled humans detected as Bernoulli distributed,</p>
<p><span id="eq-Humans_detected_distribution"><span class="math display">\[X_{[H],j}\sim Bernoulli(p_{[H],j}), \tag{29}\]</span></span></p>
<p>with a logit link function,</p>
<p><span id="eq-Humans_detected_link"><span class="math display">\[logit(p_{[H],j}) = B_{[H,0]}+\mathbf{B_{[H,1]}}×\mathbf{X_{[M],j}}. \tag{30}\]</span></span></p>
<p>We modeled traffic intensity and speed as gamma distributed,</p>
<p><span id="eq-Traffic_intensity_speed_distribution"><span class="math display">\[X_{[H],j}\sim Gamma(r_{[H]}, r_{[H]} / p_{[H],j}), \tag{31}\]</span></span></p>
<p>with a log link function for the linear predictor,</p>
<p><span id="eq-Traffic_intensity_speed_link"><span class="math display">\[log(p_{[H],j}) = B_{[H,0]}+\mathbf{B_{[H,1]}}×\mathbf{X_{[M],j}}, \tag{32}\]</span></span></p>
<p>and <span class="math inline">\(r_{[H]}\)</span> representing an additionally estimated shape parameter. We used <span class="math inline">\(B \sim Normal(0,0.66667)\)</span> priors for all regression parameters (<a href="#eq-Humans_detected_link" class="quarto-xref">Equation&nbsp;30</a> and <a href="#eq-Traffic_intensity_speed_distribution" class="quarto-xref">Equation&nbsp;31</a>) and <span class="math inline">\(r \sim gamma(1,1)\)</span> for Gamma regression shape parameters (<span class="math inline">\(r_{[H]}\)</span> in <a href="#eq-Traffic_intensity_speed_distribution" class="quarto-xref">Equation&nbsp;31</a>). For path models, we implemented posterior predictive goodness-of-fit (GOF) checks, whereby p-values quantified the proportion of deviances for simuated datasets that exceeded those of observed data <span class="citation" data-cites="GelmanHill-2007">(<a href="#ref-GelmanHill-2007" role="doc-biblioref">Gelman and Hill 2007</a>)</span>. None of the p-values for these models were extreme (<span class="math inline">\(p=0.4\)</span>), indicating no evidence for lack of fit.</p>
</section>
</section>
<section id="model-fitting" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="model-fitting"><span class="header-section-number">2</span> Model fitting</h2>
<p>We fitted our analysis model in R <span class="citation" data-cites="R-base">(<a href="#ref-R-base" role="doc-biblioref">R Core Team 2023</a>)</span> using the R package NIMBLE <span class="citation" data-cites="Nimble-2017 Nimble-2023">(<a href="#ref-Nimble-2017" role="doc-biblioref">Valpine et al. 2017</a>, <a href="#ref-Nimble-2023" role="doc-biblioref">2023</a>)</span>. We ran three parallel MCMC chains with burn-in = 10000. We checked convergence and sampling metrics every 20100 iterations, limited the number of posterior samples saved to 1000, and discontinued sampling once we had reached <span class="math inline">\(\widehat{R} \le 1.1\)</span> and <span class="math inline">\(n_{effective} \ge 100\)</span> for all parameters <span class="citation" data-cites="GelmanHill-2007">(<a href="#ref-GelmanHill-2007" role="doc-biblioref">Gelman and Hill 2007</a>)</span>. With these specifications and constraints, our final chain length = 482400 iterations with a thinning rate of 472.4. We also visually inspected trace plots for parameters with the least <span class="math inline">\(n_{effective}\)</span> and greatest <span class="math inline">\(\widehat{R}\)</span> to further verify arrival of MCMC sampling at a stationary distribution.</p>
</section>
<section id="derived-parameters" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="derived-parameters"><span class="header-section-number">3</span> Derived parameters</h2>
<section id="sec-N_p" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="sec-N_p"><span class="header-section-number">3.1</span> Predicted abundance adjusted for cluster size</h3>
<p>We drew inference primarily from comparisons of predicted diversity across covariate space, which first required predicting species abundance. If we represent a location in covariate space to which we wanted to predict as <span class="math inline">\(\mathbf{X_p}\)</span>, we predicted mean abundance at that location as</p>
<p><span id="eq-pred_N"><span class="math display">\[N_{p,i}=\lambda_{p,i}×c_i, \tag{33}\]</span></span></p>
<p>where <span class="math inline">\(\lambda_{p,i}\)</span> is calculated as</p>
<p><span id="eq-pred_lambda"><span class="math display">\[log(\lambda_{p,i})=β_{0,i}+\mathbf{β_{1,i}}×\mathbf{X_p}, \tag{34}\]</span></span></p>
<p>and <span class="math inline">\(c_i\)</span> is cluster size for species <span class="math inline">\(i\)</span>. Of <span class="math inline">\(51,163\)</span> detected clusters, <span class="math inline">\(97.4\%\)</span> consisted of a single detected individual and the remaining <span class="math inline">\(2.6\%\)</span> of clusters consisted of <span class="math inline">\(\geq 2\)</span> non-independently detected individuals (e.g., members of breeding pair detected together). When possible, we derived <span class="math inline">\(c_i\)</span> by drawing values for each MCMC posterior sample from a truncated normal distribution, <span class="math inline">\(\widehat{\overline{c_i}} \sim Normal(\overline{X_{c_i}},SE_{X_{c_i}})T(1,)\)</span>, where <span class="math inline">\(\overline{X_{c_i}}\)</span> and <span class="math inline">\(SE_{X_{c_i}}\)</span> are the sample mean and standard error (<span class="math inline">\(SE_{X_{c_i}}=SD_{X_{c_i}}/\sqrt{n}\)</span>), respectively. For 55 species, we either recorded all cluster sizes = 1 or detected only one cluster, in which case <span class="math inline">\(SE_{X_{c_i}}\)</span> was undefined so <span class="math inline">\(c_i=\overline{X_{c_i}}\)</span>.</p>
</section>
<section id="diversity" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="diversity"><span class="header-section-number">3.2</span> Diversity</h3>
<p>We used the Hill-Shannon index to quantify bird diversity <span class="citation" data-cites="RoswellEtAl-2021">(<a href="#ref-RoswellEtAl-2021" role="doc-biblioref">Roswell, Dushoff, and Winfree 2021</a>)</span>. For any species group <span class="math inline">\(I\)</span>, we derived predicted diversity as</p>
<p><span id="eq-pred_D"><span class="math display">\[D_p = exp\left(-1×\sum_{i=1}^{I}\left(\frac{N_{p,i}}{\sum_{i=1}^{I}N_{p,i}}×log\left(\frac{N_{p,i}}{\sum_{i=1}^{I}N_{p,i}}\right)\right)\right). \tag{35}\]</span></span></p>
<p>Figures 3 and 4 present <span class="math inline">\(D_p\)</span> along covariate gradients, and we used differences in <span class="math inline">\(D_p\)</span> between alternative locations in covariate space to partition management relationships with diversity into their underlying components (see <a href="#sec-path_analysis" class="quarto-xref">Section&nbsp;4</a>).</p>
</section>
</section>
<section id="sec-path_analysis" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-path_analysis"><span class="header-section-number">4</span> Path analysis</h2>
<section id="sec-total_relations" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="sec-total_relations"><span class="header-section-number">4.1</span> Total management relationships</h3>
<p>We followed <span class="citation" data-cites="Clough-2012">Clough (<a href="#ref-Clough-2012" role="doc-biblioref">2012</a>)</span> to quantify components of management relationships with bird diversity. We expressed the total relationship of a management covariate, <span class="math inline">\(X_{[M]}\)</span>, with bird diversity as</p>
<p><span id="eq-total_management_effect"><span class="math display">\[B_{[M,T]}^{[D]}=log(D_{p,M}/D_{p,R}), \tag{36}\]</span></span></p>
<p>where <span class="math inline">\(D_{p,M}\)</span> and <span class="math inline">\(D_{p,R}\)</span> are predicted diversity (<a href="#eq-pred_D" class="quarto-xref">Equation&nbsp;35</a>) calculated with covariate values representing management and reference scenarios, respectively. The set of covariate values representing management and reference scenarios depended on which management relationship we were deriving. We identified 5 fundamental scenarios for calculating total management relationships (vegetation covariates set to their mean for all scenarios):</p>
<div class="hanging-indent">
<p><em>Baseline</em> - <span class="math inline">\(X_{p}^{[Base]}\)</span> - Trail and road densities are set to <span class="math inline">\(0\)</span>, and proportion no OHV set to its mean.<br></p>
</div>
<div class="hanging-indent">
<p><em>Some trails, average OHV</em> - <span class="math inline">\(X_{p}^{[Trails,\overline{OHV}]}\)</span> - Trail density is set to <span class="math inline">\(2.0~km/km^2\)</span> (i.e., <span class="math inline">\(0+1SD\)</span>), road density to <span class="math inline">\(0\)</span>, and proportion no OHV to its mean.<br></p>
</div>
<div class="hanging-indent">
<p><em>Some trails, no OHV</em> - <span class="math inline">\(X_{p}^{[Trails,OHV=0]}\)</span> - Trail density is set to <span class="math inline">\(2.0~km/km^2\)</span>, road density to <span class="math inline">\(0\)</span>, and proportion no OHV to <span class="math inline">\(0\)</span>.<br></p>
</div>
<div class="hanging-indent">
<p><em>Some trails, unrestricted OHV</em> - <span class="math inline">\(X_{p}^{[Trails,OHV=1]}\)</span> - Trail density is set to <span class="math inline">\(2.0~km/km^2\)</span>, road density to <span class="math inline">\(0\)</span>, and proportion no OHV to <span class="math inline">\(1\)</span>.<br></p>
</div>
<div class="hanging-indent">
<p><em>Some roads</em> - <span class="math inline">\(X_{p}^{[Roads]}\)</span> - Road density is set to <span class="math inline">\(1.0~km/km^2\)</span> (i.e., <span class="math inline">\(0+1SD\)</span>), trail density to <span class="math inline">\(0\)</span>, and proportion no OHV to its mean.<br></p>
</div>
<p>For total management relationships, we set values for each human traffic covariate, <span class="math inline">\(X_{[H],p}\)</span>, to <span class="math inline">\(p_{[H]}\)</span> from the corresponding path model (<a href="#eq-Humans_detected_link" class="quarto-xref">Equation&nbsp;30</a> or <a href="#eq-Traffic_intensity_speed_link" class="quarto-xref">Equation&nbsp;32</a>) informed with scenario-specific management covariate values. We then assigned management and reference scenarios for calculating total management relationships (<a href="#eq-total_management_effect" class="quarto-xref">Equation&nbsp;36</a>) as follows:</p>
<p>Trail density - management = <em>Some trails, average OHV</em>; reference = <em>Baseline</em><br> Road density - management = <em>Some roads</em>; reference = <em>Baseline</em><br> Proportion no OHV - management = <em>Some trails, no OHV</em>; reference = <em>Some trails, unrestricted OHV</em><br></p>
</section>
<section id="sec-mech_contributions" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="sec-mech_contributions"><span class="header-section-number">4.2</span> Mechanistic contributions</h3>
<p>We quantified the percent contribution of human traffic to management relationships with diversity by calculating the portion of the total relationship explained by human traffic <span class="citation" data-cites="Clough-2012">(i.e., indirect relationship <em>sensu</em> <a href="#ref-Clough-2012" role="doc-biblioref">Clough 2012</a>)</span>, and then dividing the explained by the total relationship (and multiplying by 100). For the explained portion of the total relationship, we first defined a counter-factual scenario wherein human traffic covariates were set to values representing the reference instead of management levels. For example, the counter-factual scenario for calculating the proportion of the trail density effect would be represented by setting management covariates to <em>Some trails, average OHV</em> but human traffic covariates to <em>Baseline</em>. We then calculated the explained portion of the management relationship as</p>
<p><span id="eq-explained_management_effect"><span class="math display">\[B_{[M,E]}^{[D]}=log(D_{p,M}/D_{p,C}), \tag{37}\]</span></span></p>
<p>where <span class="math inline">\(D_{p,C}\)</span> is predicted diversity under the counter-factual scenarios. We then calculate the percent contribution of human traffic as</p>
<p><span id="eq-percent_explained"><span class="math display">\[P_{H}=\left(B_{[M,E]}/B_{[M,T]}\right)×100. \tag{38}\]</span></span></p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-BucklandEtAl-2001" class="csl-entry" role="listitem">
Buckland, Stephen T., David R. Anderson, Kenneth P. Burnham, Jeffery L. Laake, David L. Borchers, and Len Thomas. 2001. <em>Introduction to Distance Sampling: Estimating Abundance of Biological Populations</em>. Oxford, United Kingdom: Oxford University Press.
</div>
<div id="ref-Clough-2012" class="csl-entry" role="listitem">
Clough, Yann. 2012. <em>A Generalized Approach to Modeling and Estimating Indirect Effects in Ecology</em>. <em>Ecology</em>. Vol. 93. <a href="https://doi.org/10.1890/11-1899.1">https://doi.org/10.1890/11-1899.1</a>.
</div>
<div id="ref-GelmanHill-2007" class="csl-entry" role="listitem">
Gelman, Andrew, and Jennifer Hill. 2007. <em>Data Analysis Using Regression and Multilevel/ Hierarchical Models</em>. New York, NY: Cambridge University Press.
</div>
<div id="ref-R-base" class="csl-entry" role="listitem">
R Core Team. 2023. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-RoswellEtAl-2021" class="csl-entry" role="listitem">
Roswell, Michael, Jonathan Dushoff, and Rachael Winfree. 2021. <em>A Conceptual Guide to Measuring Species Diversity</em>. <em>Oikos</em>. Vol. 130. <a href="https://doi.org/10.1111/oik.07202">https://doi.org/10.1111/oik.07202</a>.
</div>
<div id="ref-Nimble-2023" class="csl-entry" role="listitem">
Valpine, Perry de, Chris Paciorek, Daniel Turek, N. Michaud, Clifford Anderson-Bergman, F. Obermeyer, C. Wehrhahn Cortes, A. Rodrìguez, Duncan Temple Lang, and S. Paganin. 2023. <em>_NIMBLE User Manual_</em>. R package manual version 1.0.1. <a href="https://doi.org/10.5281/zenodo.1211190">https://doi.org/10.5281/zenodo.1211190</a>.
</div>
<div id="ref-Nimble-2017" class="csl-entry" role="listitem">
Valpine, Perry de, Daniel Turek, Chris J. Paciorek, Clifford Anderson-Bergman, Duncan Temple Lang, and Rastislav Bodik. 2017. <em>Programming with Models: Writing Statistical Algorithms for General Model Structures with NIMBLE</em>. <em>Journal of Computational and Graphical Statistics</em>. Vol. 26. <a href="https://doi.org/10.1080/10618600.2016.1172487">https://doi.org/10.1080/10618600.2016.1172487</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>